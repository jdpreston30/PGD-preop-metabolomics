#' Create Pathway Enrichment Dot Plot from Mummichog JSON Output
#'
#' This function creates a dot plot visualization for pathway enrichment results
#' by reading directly from the scattermum.json files generated by MetaboAnalystR.
#' Uses grid layout with white tiles and blue color scheme.
#'
#' @param json_files Named list of JSON file paths for each comparison OR nested list for multiple databases
#'   Single database: list(nosev = "path1.json", modsev = "path2.json", allsev = "path3.json")
#'   Multiple databases: list(mfn = list(nosev = "path1.json", ...), kegg = list(nosev = "path4.json", ...))
#' @param combine_databases Logical indicating whether json_files contains multiple databases (default FALSE)
#' @param p_threshold Numeric p-value threshold for significance (default 0.05)
#' @param enrichment_cap Numeric maximum value to cap enrichment factors (default 5)
#' @param size_range Numeric vector of length 2 for dot size range (default c(5, 10))
#' @param size_breaks Numeric vector for size scale breaks (auto-generated if NULL)
#' @param show_legend Logical indicating whether to show legends (default TRUE)
#' @param plot_title Optional title for the plot (default NULL)
#' @param save_path Optional file path to save the plot (default NULL)
#' @param plot_width Numeric width for saved plot in inches (default NULL - auto-calculated)
#' @param plot_height Numeric height for saved plot in inches (default NULL - auto-calculated)
#' @param width_per_comparison Numeric width per comparison column in inches (default 0.3)
#' @param width_base Numeric base width in inches (default 7 with legend, 4.2 without)
#' @param height_per_pathway Numeric height per pathway row in inches (default 0.3)
#' @param height_base Numeric base height in inches (default 2)
#' @param dpi Numeric resolution for saved plot (default 600)
#' @param color_scale Character string for color scheme: "red" (default) or "blue"
#'
#' @return A ggplot2 object
#'
#' @examples
#' \dontrun{
#'   # Single database plot
#'   json_files <- list(
#'     nosev = "Outputs/mummichog/outputs/nosev/MFN/scattermum.json",
#'     modsev = "Outputs/mummichog/outputs/modsev/MFN/scattermum.json",
#'     allsev = "Outputs/mummichog/outputs/allsev/MFN/scattermum.json"
#'   )
#'   
#'   plot <- plot_mummichog_enrichment(
#'     json_files = json_files,
#'     combine_databases = FALSE
#'   )
#'   
#'   # With blue color scheme
#'   plot_blue <- plot_mummichog_enrichment(
#'     json_files = json_files,
#'     combine_databases = FALSE,
#'     color_scale = "blue"
#'   )
#'   
#'   # Multiple database plot
#'   multi_files <- list(
#'     mfn = list(nosev = "path1.json", modsev = "path2.json", allsev = "path3.json"),
#'     kegg = list(nosev = "path4.json", modsev = "path5.json", allsev = "path6.json")
#'   )
#'   
#'   plot <- plot_mummichog_enrichment(
#'     json_files = multi_files,
#'     combine_databases = TRUE
#'   )
#' }
#'
#' @export
plot_mummichog_enrichment <- function(
  json_files,
  combine_databases = FALSE,
  p_threshold = 0.05,
  enrichment_cap = 5,
  size_range = c(5, 10),
  size_breaks = NULL,
  show_legend = TRUE,
  plot_title = NULL,
  save_path = NULL,
  plot_width = NULL,
  plot_height = NULL,
  width_per_comparison = 0.3,
  width_base = NULL,
  height_per_pathway = 0.3,
  height_base = 2,
  dpi = 600,
  color_scale = "blue"
) {
  
  # Load required libraries
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(forcats)
  library(jsonlite)
  library(purrr)
  library(stringr)
  
  # Source clean_pathway_names function
  if (!exists("clean_pathway_names")) {
    source("../Utilities/Helpers/clean_pathway_names.R")
  }
  
  # Function to read and process JSON file (single database)
  read_mummichog_json <- function(json_path, comparison_name) {
    tryCatch({
      # Read JSON file
      json_data <- jsonlite::fromJSON(json_path)
      
      # Use -log10 p-values directly (no transformation)
      log10_p_values <- json_data$pval
      
      # Convert p_threshold to -log10 for filtering
      log10_threshold <- -log10(p_threshold)
      
      # Create tibble
      tibble(
        pathway_name = json_data$pathnames,
        log10_p = log10_p_values,
        enrichment_factor = json_data$enr,
        Comparisons = comparison_name
      ) %>%
        # Clean pathway names
        mutate(pathway_name = clean_pathway_names(pathway_name)) %>%
        # Filter for significance (higher -log10 values = more significant)
        filter(log10_p >= log10_threshold)
      
    }, error = function(e) {
      warning(paste("Could not read", json_path, ":", e$message))
      return(tibble())
    })
  }
  
  # Function to read and process JSON file (multiple databases)
  read_mummichog_json_with_db <- function(json_path, comparison_name, database_name) {
    tryCatch({
      # Read JSON file
      json_data <- jsonlite::fromJSON(json_path)
      
      # Use -log10 p-values directly (no transformation)
      log10_p_values <- json_data$pval
      
      # Convert p_threshold to -log10 for filtering
      log10_threshold <- -log10(p_threshold)
      
      # Create tibble
      tibble(
        pathway_name = json_data$pathnames,
        log10_p = log10_p_values,
        enrichment_factor = json_data$enr,
        Comparisons = comparison_name
      ) %>%
        # Clean pathway names and add database suffix
        mutate(
          pathway_name = clean_pathway_names(pathway_name),
          pathway_name = paste0(pathway_name, " (", toupper(database_name), ")")
        ) %>%
        # Filter for significance (higher -log10 values = more significant)
        filter(log10_p >= log10_threshold)
      
    }, error = function(e) {
      warning(paste("Could not read", json_path, ":", e$message))
      return(tibble())
    })
  }
  
  # Read JSON files based on combine_databases parameter
  if (combine_databases) {
    # Multiple databases - nested list format
    combined_data <- map2_dfr(
      rep(names(json_files), each = length(json_files[[1]])),
      rep(names(json_files[[1]]), times = length(json_files)),
      function(db_name, comp_name) {
        json_path <- json_files[[db_name]][[comp_name]]
        read_mummichog_json_with_db(json_path, comp_name, db_name)
      }
    )
  } else {
    # Single database - simple list format  
    pathway_data_list <- map2(json_files, names(json_files), read_mummichog_json)
    combined_data <- bind_rows(pathway_data_list)
  }
  
  # Check if we have any data
  if (nrow(combined_data) == 0) {
    stop("No significant pathways found in any of the provided JSON files")
  }
  
  # Process data using the same logic as original plot_pathway_enrichment
  enrichment_data <- combined_data %>%
    tidyr::complete(pathway_name, Comparisons) %>%
    mutate(
      Comparisons = dplyr::case_when(
        Comparisons == "nosev" ~ "0v3",
        Comparisons == "modsev" ~ "1-2v3", 
        Comparisons == "allsev" ~ "0-2v3",
        TRUE ~ Comparisons
      ),
      Comparisons = factor(Comparisons, levels = c("0v3", "1-2v3", "0-2v3"))
    ) %>%
    # Apply enrichment factor cap
    mutate(enrichment_factor = pmin(enrichment_factor, enrichment_cap))
  
  # Different sorting logic for combined vs single database
  if (combine_databases) {
    # For combined databases: Sort by database first (KEGG then MFN), then by enrichment within each database
    
    # Find the comparison with most pathways overall
    pathway_counts <- enrichment_data %>%
      filter(!is.na(enrichment_factor)) %>%
      group_by(Comparisons) %>%
      summarise(n_pathways = n_distinct(pathway_name), .groups = "drop") %>%
      arrange(desc(n_pathways))
    
    dominant_comparison <- pathway_counts$Comparisons[1]
    
    # Extract database from pathway names and sort
    kegg_pathways <- enrichment_data %>%
      filter(str_detect(pathway_name, "\\(KEGG\\)") & 
             Comparisons == dominant_comparison & 
             !is.na(enrichment_factor)) %>%
      arrange(desc(enrichment_factor)) %>%
      pull(pathway_name) %>%
      unique()
    
    mfn_pathways <- enrichment_data %>%
      filter(str_detect(pathway_name, "\\(MFN\\)") & 
             Comparisons == dominant_comparison & 
             !is.na(enrichment_factor)) %>%
      arrange(desc(enrichment_factor)) %>%
      pull(pathway_name) %>%
      unique()
    
    # Combine: KEGG first, then MFN
    all_pathways <- unique(enrichment_data$pathway_name)
    remaining_pathways <- setdiff(all_pathways, c(kegg_pathways, mfn_pathways))
    pathway_order <- c(kegg_pathways, mfn_pathways, remaining_pathways)
    
  } else {
    # For single database: Original sorting logic
    
    # Find the comparison group with the most significant pathways (bubbles)
    pathway_counts <- enrichment_data %>%
      filter(!is.na(enrichment_factor)) %>%
      group_by(Comparisons) %>%
      summarise(n_pathways = n_distinct(pathway_name), .groups = "drop") %>%
      arrange(desc(n_pathways))
    
    # Get the comparison with the most pathways
    dominant_comparison <- pathway_counts$Comparisons[1]
    
    # Order pathways by enrichment factor in the dominant comparison
    dominant_order <- enrichment_data %>%
      filter(Comparisons == dominant_comparison & !is.na(enrichment_factor)) %>%
      arrange(desc(enrichment_factor)) %>%
      pull(pathway_name) %>%
      unique()
    
    # Add remaining pathways
    all_pathways <- unique(enrichment_data$pathway_name)
    remaining_pathways <- setdiff(all_pathways, dominant_order)
    pathway_order <- c(dominant_order, remaining_pathways)
  }
  
  # Apply the pathway ordering
  enrichment_data <- enrichment_data %>%
    mutate(pathway_name = factor(pathway_name, levels = pathway_order))
  
  # Auto-generate size breaks if not provided (same as original)
  if (is.null(size_breaks)) {
    size_breaks <- pretty(c(0, enrichment_cap), n = 4)
    size_breaks <- size_breaks[size_breaks <= enrichment_cap & size_breaks > 0]
  }
  
  # Create the plot using EXACT same style as original plot_pathway_enrichment
  p <- ggplot(
    enrichment_data,
    aes(x = 0.5, y = 0.5, size = enrichment_factor, color = log10_p)
  ) +
    geom_tile(
      data = data.frame(x = 0.5, y = 0.5),
      aes(x = x, y = y),
      width = 1, height = 1,
      fill = "white", colour = "grey80", linewidth = 0.3,
      inherit.aes = FALSE
    ) +
    geom_point(
      alpha = 0.95, shape = 16, stroke = 0,
      na.rm = TRUE, show.legend = show_legend
    )
  
  # Determine faceting based on number of comparisons
  n_comparisons <- length(unique(enrichment_data$Comparisons))
  
  if (n_comparisons == 1) {
    # Single column layout - use facet_wrap for cleaner single-column display
    p <- p + facet_wrap(
      vars(pathway_name),
      ncol = 1,
      strip.position = "left"
    )
  } else {
    # Multi-column layout - use facet_grid as before
    p <- p + facet_grid(
      rows = vars(pathway_name),
      cols = vars(Comparisons),
      switch = "y", drop = FALSE
    )
  }
  
  p <- p +
    coord_fixed(clip = "off") +
    scale_x_continuous(limits = c(0, 1), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
    scale_size_continuous(
      range = size_range,
      limits = c(0, enrichment_cap),
      breaks = size_breaks,
      name = "Enrichment factor",
      guide = if (show_legend) guide_legend(reverse = FALSE) else "none"
    ) +
    scale_color_gradientn(
      colors = if(color_scale == "blue") {
        c("#c3dbe9", "#4a90e2", "#0a2256", "#0a2256")  # Light blue, medium blue, dark blue, dark blue plateau
      } else {
        c("#e8d5b7ff", "#e49c30ff", "#801914ff", "#801914ff")  # Light at 1.0, orange at sig, dark red at 2.0, same dark red to 3.0
      },
      values = c(0, 0.2, 0.667, 1),  # 1.0 to 1.301 to 2.0 (plateau starts) to 2.5 (plateau continues)
      limits = c(1, 2.5),  # Fixed range from 1 to 2.5
      breaks = c(1, 1.301, 1.5, 2.0, 2.5),  # Fixed ticks: 1, asterisk, 1.5, 2.0, 2.5
      labels = c("1", "✱", "1.5", "2.0", "2.5"),  # Custom labels with centered heavy asterisk at 0.05
      oob = scales::squish,  # Values outside range get clamped to edge colors
      name = "-log10(p-value)\n"
    ) +
    guides(
      color = if (show_legend) {
        guide_colorbar(
          order = 1,  # p-value colorbar first (top)
          barheight = unit(5, "cm"),
          barwidth = unit(0.9, "cm"),
          ticks.colour = "black",
          ticks.linewidth = 0.5,
          frame.colour = NA,  # Remove black border
          frame.linewidth = 0,
          draw.ulim = TRUE,  # Show upper limit tick (at 3)
          draw.llim = TRUE   # Show lower limit tick (at 1)
        )
      } else {
        "none"
      },
      size = if (show_legend) {
        guide_legend(order = 2)  # enrichment factor size second (bottom)
      } else {
        "none"
      }
    ) +
    labs(
      x = NULL, 
      y = NULL, 
      title = plot_title,
      subtitle = if (is.null(plot_title) && n_comparisons > 1) "PGD Comparison" else NULL
    ) +
    theme_minimal(base_family = "Arial") +
    theme(
      text = element_text(family = "Arial"),
      panel.grid = element_blank(),
      panel.background = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.spacing.x = unit(0, "pt"),
      panel.spacing.y = unit(0, "pt"),
      strip.placement = "outside",
      strip.text.x.top = element_text(
        angle = 0, vjust = 0.5, hjust = 0.5,
        face = "bold", family = "Arial", size = 11, margin = margin(b = 5, 7)
      ),
      strip.text.y.left = element_text(
        angle = 0, hjust = 1,
        face = "bold", family = "Arial", size = 11,
        margin = margin(r = 6)
      ),
      legend.title = element_text(size = 11, face = "bold", family = "Arial", vjust = 0.3),
      legend.text = element_text(size = 11, family = "Arial"),
      plot.subtitle = element_text(
        hjust = 0.5, face = "bold.italic", family = "Arial", size = 12,
        margin = margin(t = -12, b = 0)
      ),
      plot.margin = margin(t = 40, r = 40, b = 10, l = 40),
      strip.clip = "off"
    ) +
    coord_cartesian(clip = "off")
  
  # Additional theme modifications for single-column mode
  if (n_comparisons == 1) {
    p <- p + theme(
      strip.text.x.top = element_blank(),  # Hide column headers
      strip.background.x = element_blank()  # Hide column header background
    )
  }
  
  # Hide legends if requested
  if (!show_legend) {
    p <- p + theme(legend.position = "none")
  }
  
  # Save plot if path provided (same logic as original)
  if (!is.null(save_path)) {
    # Calculate dynamic dimensions based on data
    n_comparisons <- length(unique(enrichment_data$Comparisons))
    n_pathways <- length(unique(enrichment_data$pathway_name))
    
    # Set width_base default if not provided
    if (is.null(width_base)) {
      width_base <- if (show_legend) 7 else 4.2
    }
    
    # Calculate dimensions
    if (is.null(plot_width)) {
      calc_width <- n_comparisons * width_per_comparison + width_base
    } else {
      calc_width <- plot_width
    }
    
    if (is.null(plot_height)) {
      calc_height <- n_pathways * height_per_pathway + height_base
      # Add extra height for large pathway lists
      if (n_pathways > 20) {
        calc_height <- calc_height + 2
      }
    } else {
      calc_height <- plot_height
    }
    
    ggsave(
      save_path,
      p,
      width = calc_width,
      height = calc_height,
      units = "in",
      dpi = dpi
    )
    
    message("Plot saved to: ", save_path, " (", calc_width, " x ", calc_height, " inches)")
  }
  
  return(p)
}
